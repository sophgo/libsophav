// Automaticlly generated by: ::SceMiMsg
// DO NOT EDIT
// C++ Class with SceMi Message passing for type:  TLM3Api::TLMRequestParams

#pragma once

#include "bxactors/xat_scemi.h"
#include "TLMAccess.h"
#include "TLMAllocate.h"
#include "TLMBSize.h"
#include "TLMBuffer.h"
#include "TLMBurstMode.h"
#include "TLMCache.h"
#include "TLMCommand.h"
#include "TLMLock.h"
#include "TLMPrivilege.h"
#include "TLMSecurity.h"

/// C++ class representing the hardware structure TLM3Api::TLMRequestParams
class TLMRequestParams : public XATType {
 public:
  BitT<1> m_spec_byte_enable ;
  BitT<1> m_cntrl_flow ;
  BitT<4> m_qos ;
  BitT<4> m_region ;
  TLMAllocate m_write_allocate ;
  TLMAllocate m_read_allocate ;
  TLMBuffer m_buffer ;
  TLMCache m_cache ;
  TLMAccess m_access ;
  TLMSecurity m_security ;
  TLMPrivilege m_privilege ;
  BitT<10> m_transaction_id ;
  TLMLock m_lock ;
  TLMBSize m_b_size ;
  TLMBurstMode m_burst_mode ;
  TLMCommand m_command ;

  /// A default constructor
  TLMRequestParams ()
    : m_spec_byte_enable()
    , m_cntrl_flow()
    , m_qos()
    , m_region()
    , m_write_allocate()
    , m_read_allocate()
    , m_buffer()
    , m_cache()
    , m_access()
    , m_security()
    , m_privilege()
    , m_transaction_id()
    , m_lock()
    , m_b_size()
    , m_burst_mode()
    , m_command()
  {}

   /**
    * @brief Constructor for object from a SceMiMessageData object
    *
    * @param msg -- the scemi message object
    * @param off -- the starting bit offset, updated to next bit position
    */
  TLMRequestParams ( const SceMiMessageDataInterface *msg, unsigned int &off )
    : m_spec_byte_enable(msg, off)
    , m_cntrl_flow(msg, off)
    , m_qos(msg, off)
    , m_region(msg, off)
    , m_write_allocate(msg, off)
    , m_read_allocate(msg, off)
    , m_buffer(msg, off)
    , m_cache(msg, off)
    , m_access(msg, off)
    , m_security(msg, off)
    , m_privilege(msg, off)
    , m_transaction_id(msg, off)
    , m_lock(msg, off)
    , m_b_size(msg, off)
    , m_burst_mode(msg, off)
    , m_command(msg, off)
  {}

  /**
   * @brief Converts this object into its bit representation for sending as a SceMi message
   *
   * @param msg -- the message object written into
   * @param off -- bit position off set in message
   * @return next free bit position for writing
   */
  unsigned int setMessageData (SceMiMessageDataInterface &msg, const unsigned int off=0) const {
    unsigned int running = off;
    running = m_spec_byte_enable.setMessageData( msg, running );
    running = m_cntrl_flow.setMessageData( msg, running );
    running = m_qos.setMessageData( msg, running );
    running = m_region.setMessageData( msg, running );
    running = m_write_allocate.setMessageData( msg, running );
    running = m_read_allocate.setMessageData( msg, running );
    running = m_buffer.setMessageData( msg, running );
    running = m_cache.setMessageData( msg, running );
    running = m_access.setMessageData( msg, running );
    running = m_security.setMessageData( msg, running );
    running = m_privilege.setMessageData( msg, running );
    running = m_transaction_id.setMessageData( msg, running );
    running = m_lock.setMessageData( msg, running );
    running = m_b_size.setMessageData( msg, running );
    running = m_burst_mode.setMessageData( msg, running );
    running = m_command.setMessageData( msg, running );
    if (running != off + 36 ) {
      std::cerr << "Mismatch in sizes: " << std::dec <<  running << " vs " << (off + 36) << std::endl;
    }
    return running;
  }

  /// overload the put-to operator for TLMRequestParams
  friend std::ostream & operator<< (std::ostream &os, const TLMRequestParams &obj) {
    XATType::PutTo * override = lookupPutToOverride ( obj.getClassName() );
    if ( override != 0 ) {
       return override(os, obj );
    }
    os << "{" ;
    os << "command " << obj.m_command ;os << " " ;
    os << "burst_mode " << obj.m_burst_mode ;os << " " ;
    os << "b_size " << obj.m_b_size ;os << " " ;
    os << "lock " << obj.m_lock ;os << " " ;
    os << "transaction_id " << obj.m_transaction_id ;os << " " ;
    os << "privilege " << obj.m_privilege ;os << " " ;
    os << "security " << obj.m_security ;os << " " ;
    os << "access " << obj.m_access ;os << " " ;
    os << "cache " << obj.m_cache ;os << " " ;
    os << "buffer " << obj.m_buffer ;os << " " ;
    os << "read_allocate " << obj.m_read_allocate ;os << " " ;
    os << "write_allocate " << obj.m_write_allocate ;os << " " ;
    os << "region " << obj.m_region ;os << " " ;
    os << "qos " << obj.m_qos ;os << " " ;
    os << "cntrl_flow " << obj.m_cntrl_flow ;os << " " ;
    os << "spec_byte_enable " << obj.m_spec_byte_enable ;os << "}" ;
    return os;
  }

  /**
   * @brief Adds to the stream the bit representation of this structure object
   *
   * @param os -- the ostream object which to append
   * @return the ostream object
   */
  virtual std::ostream & getBitString (std::ostream & os) const {
    m_command.getBitString (os);
    m_burst_mode.getBitString (os);
    m_b_size.getBitString (os);
    m_lock.getBitString (os);
    m_transaction_id.getBitString (os);
    m_privilege.getBitString (os);
    m_security.getBitString (os);
    m_access.getBitString (os);
    m_cache.getBitString (os);
    m_buffer.getBitString (os);
    m_read_allocate.getBitString (os);
    m_write_allocate.getBitString (os);
    m_region.getBitString (os);
    m_qos.getBitString (os);
    m_cntrl_flow.getBitString (os);
    m_spec_byte_enable.getBitString (os);
  return os;
  }
  

  /**
   * @brief Accessor for the XATType name for this object
   *
   * @param os -- the ostream object which to append
   * @return the ostream object
   */
  virtual std::ostream & getXATType (std::ostream & os) const {
    os << "TLM3Api::TLMRequestParams" ;
    return os;
  }

  /**
   * @brief Accessor on the size of the object in bits
   * @return the bit size
   */
  virtual unsigned int getBitSize () const {
    return 36;
  }

  /// returns the class name for this object
  virtual const char * getClassName() const {
    return "TLMRequestParams" ;
  }

  /// returns the XATKind for this object
  virtual XATKind getKind() const {
    return XAT_Struct ;
  }

  /// Accessor for the count of members in object
  virtual unsigned int getMemberCount() const {
    return 16;
  };
  
  /**
   * @brief Accessor to member objects
   *
   * @param idx -- member index
   * @return XATType * to this object or null
   */
  virtual XATType * getMember (unsigned int idx) {
    switch (idx) {
      case 0: return & m_command;
      case 1: return & m_burst_mode;
      case 2: return & m_b_size;
      case 3: return & m_lock;
      case 4: return & m_transaction_id;
      case 5: return & m_privilege;
      case 6: return & m_security;
      case 7: return & m_access;
      case 8: return & m_cache;
      case 9: return & m_buffer;
      case 10: return & m_read_allocate;
      case 11: return & m_write_allocate;
      case 12: return & m_region;
      case 13: return & m_qos;
      case 14: return & m_cntrl_flow;
      case 15: return & m_spec_byte_enable;
      default: std::cerr << "Index error in getMember for class TLMRequestParams" << std::endl ;
    };
    return 0;
  };
  
  /**
   * @brief Accessor for symbolic member names
   *
   * @param idx -- member index
   * @return char* to this name or null
   */
  virtual const char * getMemberName (unsigned int idx) const {
    switch (idx) {
      case 0: return "command";
      case 1: return "burst_mode";
      case 2: return "b_size";
      case 3: return "lock";
      case 4: return "transaction_id";
      case 5: return "privilege";
      case 6: return "security";
      case 7: return "access";
      case 8: return "cache";
      case 9: return "buffer";
      case 10: return "read_allocate";
      case 11: return "write_allocate";
      case 12: return "region";
      case 13: return "qos";
      case 14: return "cntrl_flow";
      case 15: return "spec_byte_enable";
      default: std::cerr << "Index error in getMemberName for class TLMRequestParams" << std::endl ;
    };
    return 0;
  };
};
